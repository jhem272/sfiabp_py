
User manual for ‘sfiabp’  
J.Hem, A. Poncet, P.Ronceray, D. Nishigushi, V. Démery 

The python module ‘sfiabp’ contains all the required programs to perform the analysis presented in the article. In this document, we propose to describe the main features of the module, as well as give some user tips for a fast and easy handling of the different functions. In the first part (1), we list all the sub-modules and briefly explains their contents. The main one is ‘sfiabp.vectorial’ that contains the two most important functions, ‘multicore.sfi’ to perform the SFI algorithm and ‘simulation.sim’ to simulate the dynamics of N particles. To facilitate the use of the functions, we propose in addition several tutorials accompanied with specific data sets (available at XXX). The tutorials are explained in the second part (2). For example, they illustrate the inference process with different type of basis function, present the data analysis with the measure of the relevant observables and the process of new simulations to validate the inference. In the last part (3), we describe the important functions of the program, by detailing the input/outputs.   

    1) Description of the modules

Please check the following standard modules are installed : 
numpy, copy, os, dill, pathos and  multiprocess.

sfiabp	The module containing all the required functions to perform the analysis presented in the article. 
sfiabp.vectorials	The main sub-module containing the function multicore.sfi to perform the SFI algorithm and simulation.sim, a cell list type algorithm that allows the dynamics evolution of N particles with tunable interactions. The other routines ensure the good working of these two functions.  
sfiabp.base	A sub-module managing the different basis functions, useful for the inference or the simulation processes. The important one is base2ptrigo to handle in a easy way the trigonometric basis functions of the article. 
sfiabp.display	Different routines to plot and manage efficiently the inference results in an interactive way. The main function is sfidisp_sweep. 
sfiabp.general	Additional functions useful for the data analysis. In particular, the sub-module ‘observables’ contains different functions to measure the  observables discussed in the article. 



    2) Description of the tutorials

tutorial1_trigo.py : We show a basic illustration of the SFI (stochastic force inference) method, by using the most important function of the program sfiabp/vectorial/multicore.sfi. For this, the SFI algo is apply on a set of synthetic data frames of 82 particles per frame, with an active velocity U = 6 um/s, a rotational diffusion Dr = 0.1 /s^2 and a simple radial pair interaction of form Vr = 2000/r**4. The first parameters to choose is the basis functions. The basis for the 1 particle force is given simply by the unitary active velocity  (Vx, Vy) = (cos(theta), sin(theta)), with theta being the angular orientation of the particle. The basis for the 2 particle forces is the set of trigonometric functions described in the article, which are already implemented in the library sfiabp/base/base2ptrigo. Only three parameters need to be provided : (1) the type of radial functions ( by default FuncRad = ‘PolyExp’ for  Polynomial-exponential function ), (2) the span of the radial functions VectorRad indicating the center of each functions and (3) the trigonometric order n=0,1,2…. Next, we choose the internal method for processing the drift.  The ‘Stratonovich’ mode is the unbiased method, robust against diffusion and error noises. It reduces significantly the number of frame required, but at the same time increases, the time to process a single frame. This mode is used in the article. In contrast, the classical method is denoted here the ‘Ito’ mode. The method processes more rapidly a single frame but needs a higher number of frames to converge and the convergence is biased by the different source of noises. The SFI algo is performed with the function sfiabp/vectorial/multicore.sfi. Note that although the SFI algo implements the ‘cell’ method to accelerate the process, the overall duration may be quite long and depends largely on several parameters such as the cell dimension, closely related to the number of particles to analyze, the number of frame to process and the number of basis functions. At the end, the inferred results are compared to the theoretical function with the plot function sfiabp/display/sfidisp_sweep.

tutorial2_mesh.py : The second tutorial proposes to analyze the same data set as in tutorial1 but with another set of basis functions. Sometimes, it is difficult to predict the form of the pair interaction so that it may be useful to process a first crude estimation that can guide later the choice of a finer set of basis functions. For this, the set of basis functions of type ‘mesh’ implemented in the library sfiabp/base/base2pmesh can be of practical interest. We resume the same dataset and now choose the basis functions of type ‘mesh’. For this we provide the grid in polar coordinates (r, theta1, theta2) and the type of function used for each bin of the grid, here a simple ‘Step’ function. After the SFI process is done, we compare the inferred results with the theoretical prediction. Unfortunately, the method is mainly limited by the maximum number of basis functions that the computer can handle (about 1000-1500).

tutorial3_flock.py : In this tutorial, we focus on a specific data set that emulates the flock of particles and try to reproduce the observed dynamics. The interactions to find are a mix between hydrodynamic force ( neutral squirmer ) and dipole-dipole interaction and in that respect, may look similar to the interactions found in experiments. The synthetic data contains 5000f frames showing the dynamics of 500 particles within a periodic box of size 200x200 um^2.  Through this example, we illustrate different functions of the programs that can be useful for a full analysis, for example, the measurement of different observables that describe the dynamics, the inference of the forces and the comparison between the inferred trigonometric terms and the predicted ones. At the end, we process of a new simulation with the inferred forces and compare the properties between the new simulation and the original data (autocorrelation of polarity, video analysis). As a results, we show that the inferred simulation is very similar to the original one showing that the interactions have been correctly captured.

    • Data set 

To run the tutorials, we provide two synthetic data sets (in /tutorial/data) whose main features are described below. Both data are saved in a python dictionary as .pkl file. A format that can be managed (load/save) with the standard module ‘dill’.  The meaning of the different keys of the dictionary (dict.keys()) are the following : 
-  ’X_Raw’ : The data to infer. The format must be a list of frame of dimension NxDim,  with the frame a numpy array, N the particle number, Dim the dimension of the coordinates equal to Dim=3 (x,y,theta). In case of experimental data set, the dimension can be Dim=4 , the fourth column being the identity of the particle given by the tracking method. The particle number N can vary over time. 
- ‘dtframe’ : the time interval between two frames.
 - ‘xframlim’ and ‘yframelim’ : the size of the box.
- ‘lcell’ : cell dimension used in case of data provided by a simulation.

Sim_1r4_npar_82_u_6_k_2000_5000f.pkl
Simulated data set presenting the dynamic evolution of 82 self propelled particles interacting with a simple isotropic radial pair interaction of form F(r) = k/r**4 with k = 2000. Active velocity  U = 6 um/s, rotational diffusion Dr  = 0.1  rad/s^2 and frame number Nfra = 5000 ( ‘dtframe’ = 0.1 s, ‘xframelim’ = [0,320] um, ‘yframelim’ = [0,320] um, lcell = 20 um).


Ominimal_model3_small_5000f.pkl
Data set presenting the dynamic evolution of 500 self propelled, flocking particles interacting with a complex pair interaction. The analytical form is given in the notebook (tutorial3).  Active velocity U = 6 um/s, rotational diffusion Dr  = 0.1 rad/s^2 and frame number Nfra = 5000  ( ‘dtframe’ = 0.1 s, ‘xframelim’ = [0,200] um, ‘yframelim’ = [0,200] um, lcell = 20 um ).

20180927ordered_df_pv_m.pkl
In addition we provide the first 100 frames of the experimental data set A (flocking particles) discussed in the article and provided by Ref 1. Active velocity U = 9.5 um/s, rotational diffusion Dr = 0.08 rad/s^2,  (‘dtframe’ = 1/15 s,  ‘xframelim’ = [0,420] um,  ‘yframelim’ = [0,336] um, ‘lcell’ = 21 um) 


    3) Description of functions

sfiabp.vectorial.multicore.sfi ( list_data, dtframe, fun1p, fun2p, xboxlim, yboxlim, lcell, ncore, verbose = False,  drift_mode = ’Stratonovich’, inverse_mode = ‘pinv’, edge_filter = True,  strato_diff_mode = 'ABP_Vestergaard’ , strato_diff_matrix = np.array([[0,0,0],[0,0,0],[0,0,1]]) ,  histo_mode = False, histo_vecr = np.linspace(0,lcell,2*lcell+1,endpoint=True) , histo_veca = (np.pi/180)*np.linspace(0,360,36+1,endpoint=True) )

The function implements the stochastic force inference algorithm presented in Ref 2 applied to the bi-dimensional estimation of the forces and the diffusion of a set of identical brownian particles. The stochastic trajectories of the particles are stored in list_data. Each trajectory is characterized by the time evolution of N particles with 3 coordinates : the x position (um) the y position (um) and the orientation theta (rad), regularly spaced by the time interval dtframe. The positions are constrained by the limit of the box xboxlim and yboxlim. To infer the 1,2 particle forces, the basis functions are specified respectively by fun1p, fun2p and once the process done, the function returns the corresponding inferred coefficients cof1p, cof2p. In addition, the function returns the constant diffusion matrix of shape 3x3 with the diagonal elements Dxx, Dyy and the rotational diffusion Dr. The estimation is done by the Vestergaard estimator. 
A main advantage of this function is the significant acceleration of the computation process powered by the cell method, for which the 2-particles force is taken into account only if the neighbor distance between the two particles is within a cell of size lcell. The pairwise interaction with the neighbors found outside the cell are therefore neglected. To increase the speed even more, the process of the the statistics is parallelized with the standard multiprocess library of python, the core number is provided by ncore.   

Parameters :

list_data : list of array 
List of frame, saved at regularly time interval dtframe. Each frame ‘i’  has the shape Npar_i x Ncor with Npar_i the particle number for this frame and Ncor = 3 the coordinates of the particle : x_pos (um), y_pos (um) and the orientation theta (rad). Optionally, the algorithm treats also the case Ncor = 4, the fourth column being the label of the particle (int) which is useful for experimental data where the particle number Npar_i changes over time. 
dtframe : int
Time interval between each frame.
fun1p :  list of fun
List of basis function for the 1-particle force inference. For each function, the input is the coordinates of the particle : X = np.array([x,y,theta]); the output is the force components : F = np.array([Fx,Fy,theta_dot]). For example, the unitary active force that moves forward the particle along its orientation is written as : Fact = lambda X : np.array([np.cos(X[2]), np.sin(X[2]),0])
fun2p : list of fun 
List of basis function for the 2 particle force inference. For each function, the input is the coordinate of the two interacted particles : Xi and Xj ; the output is the the force F_j->i acting on i from j. For example, the pairwise trigonometric function studied are defined in the sub-module  sfiabp.base.base2ptrigo. Please see the tutorials to see how to use these functions. 
xboxlim : array
xboxlim = np.array([lim_inf,lim_sup]) boundaries of the box along the x axis. For example, xboxlim can be equal to the boundary of the frame, but it is also possible to use a reduced xboxlim. In this case the SFI algorithm is applied only to a  restricted portion of the frame. 
Yboxlim : array
Idem for the y coordinate.
lcell :  int 
Lateral dimension of the cell, the number must a divisor of both the widths of the box, along the x and y directions.  
Ncore : int
Number of core to use for the treatment.

Optional parameters :

verbose : bol, optional
Print information related to the progress of the computation
drift_mode : { 'Stratonovich', 'Ito' }, optional
By default, the algorithm uses the ‘Stratonovich’ estimator (‘Stratonovich’) to compute the force which give in most cases better results compare to the naive approach , the ‘Ito” estimator. They both give identical results only in the absence of noise measurements and random walk. 
inverse_mode : {'name':'pinv'}
By default, the Gram matrix is inverted by the pseudo-inverse method (‘pinv’). 
edge_filter : bol, optional
The filter discards the particles closed to the box edge form the statistics while taking them into account as neighbors. Indeed, these particles may be influenced by neighbors located outside the box which may biased the force inference. The distance from the edge for which the filter applied is the length of lcell. The density histogram is non longer symmetric if the filter is enabled. 
strato_diff_mode : {'Vestergaard', 'ABP_Vestergaard', 'ABP_CST'}, optional
strato_diff_matrix : ndarray, optional
Additional parameters to provide for the process of the Stratonovich estimator (drift_mode = ‘Stratonovich’). In case of ‘Vestergaard’, the Stratonovich estimator use the local diffusion matrix estimated by the Vestergaard estimator. In case of ‘ABP_Vestergaard’, the diffusion matrix is weighted by a boolean mask of same shape, given by strato_diff_matrix. In particular, this is useful in our study, since the the spatial diffusion can be neglected (Dxx = Dyy = 0)  but not the rotational diffusion Dr, so that the mask is np.array([[0,0,0],[0,0,0],[0,0,1]]). In the last option ‘ABP_CST’, the already known diffusion matrix is directly provided to strato_diff_matrix which accelerates the computation. 
histo_mode :  boolean, optional
histo_vecr : ndarray, optional
histo_veca : ndarray, optional
If histo_mode enabled, compute the pair histogram in polar coordinates (r, thata_i, theta_j) in the same time of the SFI process. The radial bins (um) are delimited by the vector histo_vecr (by default : np.linspace( 0,lcell, 2*lcell+1, endpoint=True)) and the angular bins (rad) by histo_veca (by default : (np.pi/180)*np.linspace(0,360,36+1,endpoint=True) ) 

Returns :

cof1p :  List of ndarray
Inferred coefficient related to the 1 particle forces, same order of appearance as for fun1p . 
cof2p : List of ndarray
Inferred coefficient related to the 2 particle forces, same order of appearance as for fun2p . 
D_average : ndarray
Diffusion matrix of shape 3x3 computed by the Vestergaard estimator.
psfi : dict
	Output dictionary that collects the parameters used for the SFI process and several information related to the process. The main keys are the followings : 
‘histo’ : ndarray
Pair histogram in polar coordinates. The radial bins (um) are stored in psfi[‘histo_vecr’] and the angular bins (rad) in psfi[‘histo_veca’].  
‘stat_weight’ : int
Effective number of particles computed by the SFI process 
‘pair_stat_weight’ : int 
Effective number of neighbors computed by the SFI process, must be equal to np.sum(histo) 
‘time’ : float
Elapsed time (s) to execute the function.  


sfiabp.vectorial.simulation.sim ( npar, nfra, dtframe, dtinc, xlim, ylim , lcell, fun1p, fun2p, fundiff, isim = 0, verbose = False,  prer = prer, frame_init = frame_init )

The function process the temporal evolution of npar brownian particles, that moves within a box of size xlim and ylim. To increase the speed of the simulation, the function use the cell list algorithm  with the cell dimension given by lcell. At time t = 0, the initial frame is set to frame_init or by default composed of uniformly distributed particles (x position (um), y position (um) and the orientation theta (rad)), then for each time increment dtinc, the simulation computes the next frame. A total of nfra number of frame spaced from dtframe are saved. The 1 particle function as well as the  pairwise interaction and the tensor diffusion are provided by the list of function : fun1p, fun2p and fundiff. Finally the trajectories and different parameters of the simulation are collected and return in a output dictionary.   

Parameters :

npar : int 
Number of particle which is constant during the whole simulation.  
nfra : int 
Number of frame to save. 
dtframe : int
Time interval (s) between each frame.
dtinc : int
Time integration (s) of the simulation with the condition dtinc < dtframe. 
xlim : int
ylim : int
The algorithm implements the periodic boundary conditions with the spatial boundaries 0 <= x < xlim, and 0 <= y < ylim along respectively the x and y component. 
lcell : int
Cell dimension which must be a divisor of both xlim and ylim.    
fun1p : list of fun
fun2p : list of fun 
List of 1 and 2 particle forces. 
fundiff : list of fun
List of tensor diffusion.

Optional Parameters :

isim : int 
A number that label the simulation and fix the seed of the random generator. 
verbose : int 
Print information related to the progress of the computation
prer : int
Number of simulation step increment before saving the first frame.

Returns :

SimData : dict
Output dictionary that collects the results of the simulation inference. 
See below the meaning of the different keys.
	‘X_Raw’ : list of ndarray
List of frames that collect the particle trajectories over time.
‘dtframe’ : List of ndarray
Time interval (s) between two consecutive frames. 
‘xframelim’ : ndarray
‘yframelim’ : ndrarray
Spatial boundaries (um) of the simulation. xframelim = np.array([0,xlim]) and yframelim = np.array([0,ylim]). 
‘P’ : dict
Parameters of the simulation.
‘time’ : float
Elapsed time (s) to execute the function.  

    4) References
1. J. Iwasawa, D. Nishigushi and M. Sano. Physical Review Research, 3:043104, 2021
2. A. Frishman and P. Ronceray Physical Review X, 10(2):021009, 2020
3. A. Poncet et al. Physical Review E, 103(1):012605, 2021
